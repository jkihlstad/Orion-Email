//
//  AIModels.swift
//  EmailApp
//
//  AI-related models for the email assistant service
//

import Foundation

// MARK: - Thread Summary

/// Summary of an email thread generated by AI
public struct ThreadSummary: Codable, Identifiable, Equatable, Sendable {
    public let id: String
    public let threadId: String
    public let summary: String
    public let keyPoints: [String]
    public let sentiment: Sentiment
    public let urgency: UrgencyLevel
    public let generatedAt: Date

    public init(
        id: String = UUID().uuidString,
        threadId: String,
        summary: String,
        keyPoints: [String],
        sentiment: Sentiment,
        urgency: UrgencyLevel,
        generatedAt: Date = Date()
    ) {
        self.id = id
        self.threadId = threadId
        self.summary = summary
        self.keyPoints = keyPoints
        self.sentiment = sentiment
        self.urgency = urgency
        self.generatedAt = generatedAt
    }
}

/// Sentiment classification for email content
public enum Sentiment: String, Codable, CaseIterable, Sendable {
    case positive
    case negative
    case neutral
    case mixed
    case urgent

    public var displayName: String {
        switch self {
        case .positive: return "Positive"
        case .negative: return "Negative"
        case .neutral: return "Neutral"
        case .mixed: return "Mixed"
        case .urgent: return "Urgent"
        }
    }

    public var systemImageName: String {
        switch self {
        case .positive: return "face.smiling"
        case .negative: return "face.frowning"
        case .neutral: return "face.neutral"
        case .mixed: return "face.questioning"
        case .urgent: return "exclamationmark.triangle"
        }
    }
}

/// Urgency level classification
public enum UrgencyLevel: String, Codable, CaseIterable, Sendable {
    case low
    case medium
    case high
    case critical

    public var displayName: String {
        switch self {
        case .low: return "Low"
        case .medium: return "Medium"
        case .high: return "High"
        case .critical: return "Critical"
        }
    }

    public var priority: Int {
        switch self {
        case .low: return 1
        case .medium: return 2
        case .high: return 3
        case .critical: return 4
        }
    }
}

// MARK: - Suggested Reply

/// AI-generated reply suggestion
public struct SuggestedReply: Codable, Identifiable, Equatable, Sendable {
    public let id: String
    public let text: String
    public let tone: ReplyTone
    public let confidence: Float
    public let generatedAt: Date

    public init(
        id: String = UUID().uuidString,
        text: String,
        tone: ReplyTone,
        confidence: Float = 0.8,
        generatedAt: Date = Date()
    ) {
        self.id = id
        self.text = text
        self.tone = tone
        self.confidence = confidence
        self.generatedAt = generatedAt
    }
}

/// Tone classification for reply suggestions
public enum ReplyTone: String, Codable, CaseIterable, Sendable {
    case formal
    case casual
    case brief
    case friendly
    case professional

    public var displayName: String {
        switch self {
        case .formal: return "Formal"
        case .casual: return "Casual"
        case .brief: return "Brief"
        case .friendly: return "Friendly"
        case .professional: return "Professional"
        }
    }

    public var description: String {
        switch self {
        case .formal: return "Professional and structured"
        case .casual: return "Relaxed and conversational"
        case .brief: return "Short and to the point"
        case .friendly: return "Warm and approachable"
        case .professional: return "Business appropriate"
        }
    }
}

// MARK: - Extracted Task

/// Task extracted from email content by AI
public struct ExtractedTask: Codable, Identifiable, Equatable, Sendable {
    public let id: String
    public let messageId: String
    public let description: String
    public let dueDate: Date?
    public let priority: TaskPriority
    public let assignee: String?
    public let confidence: Float
    public let extractedAt: Date

    public init(
        id: String = UUID().uuidString,
        messageId: String,
        description: String,
        dueDate: Date? = nil,
        priority: TaskPriority = .medium,
        assignee: String? = nil,
        confidence: Float = 0.8,
        extractedAt: Date = Date()
    ) {
        self.id = id
        self.messageId = messageId
        self.description = description
        self.dueDate = dueDate
        self.priority = priority
        self.assignee = assignee
        self.confidence = confidence
        self.extractedAt = extractedAt
    }
}

/// Priority level for extracted tasks
public enum TaskPriority: String, Codable, CaseIterable, Sendable {
    case low
    case medium
    case high
    case urgent

    public var displayName: String {
        switch self {
        case .low: return "Low"
        case .medium: return "Medium"
        case .high: return "High"
        case .urgent: return "Urgent"
        }
    }

    public var sortOrder: Int {
        switch self {
        case .urgent: return 0
        case .high: return 1
        case .medium: return 2
        case .low: return 3
        }
    }
}

// MARK: - AI Response

/// Generic AI response for questions about emails
public struct AIResponse: Codable, Identifiable, Equatable, Sendable {
    public let id: String
    public let answer: String
    public let sources: [AISource]
    public let confidence: Float
    public let generatedAt: Date

    public init(
        id: String = UUID().uuidString,
        answer: String,
        sources: [AISource] = [],
        confidence: Float = 0.8,
        generatedAt: Date = Date()
    ) {
        self.id = id
        self.answer = answer
        self.sources = sources
        self.confidence = confidence
        self.generatedAt = generatedAt
    }
}

/// Source reference for AI responses
public struct AISource: Codable, Identifiable, Equatable, Sendable {
    public let id: String
    public let messageId: String
    public let snippet: String
    public let relevanceScore: Float

    public init(
        id: String = UUID().uuidString,
        messageId: String,
        snippet: String,
        relevanceScore: Float
    ) {
        self.id = id
        self.messageId = messageId
        self.snippet = snippet
        self.relevanceScore = relevanceScore
    }
}

// MARK: - Memory Chip

/// Memory chip representing related context from user's memory store
public struct MemoryChip: Codable, Identifiable, Equatable, Sendable {
    public let id: String
    public let title: String
    public let snippet: String
    public let relevanceScore: Float
    public let memoryType: MemoryType
    public let sourceDate: Date?
    public let metadata: [String: String]?

    public init(
        id: String = UUID().uuidString,
        title: String,
        snippet: String,
        relevanceScore: Float,
        memoryType: MemoryType = .general,
        sourceDate: Date? = nil,
        metadata: [String: String]? = nil
    ) {
        self.id = id
        self.title = title
        self.snippet = snippet
        self.relevanceScore = relevanceScore
        self.memoryType = memoryType
        self.sourceDate = sourceDate
        self.metadata = metadata
    }
}

/// Type classification for memory chips
public enum MemoryType: String, Codable, CaseIterable, Sendable {
    case email
    case contact
    case event
    case note
    case task
    case general

    public var displayName: String {
        switch self {
        case .email: return "Email"
        case .contact: return "Contact"
        case .event: return "Event"
        case .note: return "Note"
        case .task: return "Task"
        case .general: return "General"
        }
    }

    public var systemImageName: String {
        switch self {
        case .email: return "envelope"
        case .contact: return "person"
        case .event: return "calendar"
        case .note: return "note.text"
        case .task: return "checkmark.circle"
        case .general: return "brain"
        }
    }
}

// MARK: - Consent Types

/// Types of consent required for various features
public enum ConsentType: String, Codable, CaseIterable, Sendable {
    case emailContent = "email.content"
    case audioCapture = "audio.capture"
    case aiAnalysis = "ai.analysis"
    case voiceSynthesis = "voice.synthesis"

    public var displayName: String {
        switch self {
        case .emailContent: return "Email Content Access"
        case .audioCapture: return "Audio Recording"
        case .aiAnalysis: return "AI Analysis"
        case .voiceSynthesis: return "Voice Synthesis"
        }
    }

    public var description: String {
        switch self {
        case .emailContent:
            return "Allow the app to access and process your email content for AI features"
        case .audioCapture:
            return "Allow the app to record audio for voice dictation"
        case .aiAnalysis:
            return "Allow AI to analyze your emails for summaries, tasks, and suggestions"
        case .voiceSynthesis:
            return "Allow the app to read emails aloud using text-to-speech"
        }
    }

    public var systemImageName: String {
        switch self {
        case .emailContent: return "envelope.open"
        case .audioCapture: return "mic"
        case .aiAnalysis: return "brain"
        case .voiceSynthesis: return "speaker.wave.3"
        }
    }
}

// MARK: - Voice Types

/// Available TTS voice options
public enum VoiceType: String, Codable, CaseIterable, Sendable {
    case alloy
    case echo
    case fable
    case onyx
    case nova
    case shimmer

    public var displayName: String {
        switch self {
        case .alloy: return "Alloy"
        case .echo: return "Echo"
        case .fable: return "Fable"
        case .onyx: return "Onyx"
        case .nova: return "Nova"
        case .shimmer: return "Shimmer"
        }
    }

    public var description: String {
        switch self {
        case .alloy: return "Neutral, balanced voice"
        case .echo: return "Warm, conversational voice"
        case .fable: return "Expressive, storytelling voice"
        case .onyx: return "Deep, authoritative voice"
        case .nova: return "Friendly, upbeat voice"
        case .shimmer: return "Clear, professional voice"
        }
    }
}

// MARK: - Request/Response Models

/// Request for AI operations
public struct AIRequest: Codable, Sendable {
    public let operation: AIOperation
    public let threadId: String?
    public let messageId: String?
    public let question: String?
    public let options: AIRequestOptions?

    public init(
        operation: AIOperation,
        threadId: String? = nil,
        messageId: String? = nil,
        question: String? = nil,
        options: AIRequestOptions? = nil
    ) {
        self.operation = operation
        self.threadId = threadId
        self.messageId = messageId
        self.question = question
        self.options = options
    }
}

/// AI operation types
public enum AIOperation: String, Codable, Sendable {
    case summarize
    case suggestReplies
    case extractTasks
    case askQuestion
    case getRelatedMemories
}

/// Options for AI requests
public struct AIRequestOptions: Codable, Sendable {
    public let maxResults: Int?
    public let preferredTone: ReplyTone?
    public let includeMemories: Bool?

    public init(
        maxResults: Int? = nil,
        preferredTone: ReplyTone? = nil,
        includeMemories: Bool? = nil
    ) {
        self.maxResults = maxResults
        self.preferredTone = preferredTone
        self.includeMemories = includeMemories
    }
}

// MARK: - Transcription Models

/// Transcription result from Whisper
public struct TranscriptionResult: Codable, Equatable, Sendable {
    public let text: String
    public let language: String?
    public let duration: TimeInterval?
    public let confidence: Float?

    public init(
        text: String,
        language: String? = nil,
        duration: TimeInterval? = nil,
        confidence: Float? = nil
    ) {
        self.text = text
        self.language = language
        self.duration = duration
        self.confidence = confidence
    }
}

// MARK: - TTS Models

/// TTS request configuration
public struct TTSRequest: Codable, Sendable {
    public let text: String
    public let voice: VoiceType
    public let speed: Float

    public init(
        text: String,
        voice: VoiceType = .alloy,
        speed: Float = 1.0
    ) {
        self.text = text
        self.voice = voice
        self.speed = max(0.25, min(4.0, speed))
    }
}

// MARK: - Error Types

/// Errors specific to AI operations
public enum AIError: Error, LocalizedError, Sendable {
    case noConsent(ConsentType)
    case networkError(underlying: Error)
    case serverError(statusCode: Int, message: String)
    case decodingError(underlying: Error)
    case invalidRequest(reason: String)
    case rateLimited(retryAfter: TimeInterval?)
    case serviceUnavailable
    case unauthorized
    case unknown(message: String)

    public var errorDescription: String? {
        switch self {
        case .noConsent(let type):
            return "Consent required for \(type.displayName)"
        case .networkError(let underlying):
            return "Network error: \(underlying.localizedDescription)"
        case .serverError(let code, let message):
            return "Server error (\(code)): \(message)"
        case .decodingError(let underlying):
            return "Failed to parse response: \(underlying.localizedDescription)"
        case .invalidRequest(let reason):
            return "Invalid request: \(reason)"
        case .rateLimited(let retryAfter):
            if let retry = retryAfter {
                return "Rate limited. Retry after \(Int(retry)) seconds"
            }
            return "Rate limited. Please try again later"
        case .serviceUnavailable:
            return "AI service is temporarily unavailable"
        case .unauthorized:
            return "Authentication required"
        case .unknown(let message):
            return message
        }
    }

    public var isRetryable: Bool {
        switch self {
        case .rateLimited, .serviceUnavailable, .networkError:
            return true
        default:
            return false
        }
    }
}

/// Errors specific to voice/audio operations
public enum VoiceError: Error, LocalizedError, Sendable {
    case noConsent(ConsentType)
    case microphonePermissionDenied
    case audioSessionError(underlying: Error)
    case recordingFailed(reason: String)
    case transcriptionFailed(reason: String)
    case playbackFailed(reason: String)
    case invalidAudioData
    case serviceUnavailable
    case cancelled

    public var errorDescription: String? {
        switch self {
        case .noConsent(let type):
            return "Consent required for \(type.displayName)"
        case .microphonePermissionDenied:
            return "Microphone access is required for voice dictation"
        case .audioSessionError(let underlying):
            return "Audio session error: \(underlying.localizedDescription)"
        case .recordingFailed(let reason):
            return "Recording failed: \(reason)"
        case .transcriptionFailed(let reason):
            return "Transcription failed: \(reason)"
        case .playbackFailed(let reason):
            return "Playback failed: \(reason)"
        case .invalidAudioData:
            return "Invalid audio data"
        case .serviceUnavailable:
            return "Voice service is temporarily unavailable"
        case .cancelled:
            return "Operation was cancelled"
        }
    }
}
